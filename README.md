# 基于 Rust + SlintUI 实现的跨全平台的小电视项目

## 消息通信机制的设计

整套程序采用消息传递机制完成整个 app 框架的设计，各个组件仅通过消息进行相互耦合实现通信，各个通信节点称为`Node`，通过枚举`NodeName`可以唯一标识一个组件。平台无关的组件放置在 app-core 中，平台相关的组件放置在各个平台的实现中。所有消息均实现了`serde::Serialize`和`serde::Deserialize`，故可天然通过 http 或 mqtt 传输 app 内的任意消息，使得 RPC 调用程序内的任意功能成为一个天然的可能，无需专门编写复杂的接口适配，同时这也为分布式 app 的可能性奠定了基础，app 内的各个组件节点可以分布工作在其他远程机器之上。

### App 中消息通信机制的一些基本概念

**节点 Node**
一个节点实际上就作为 app 内的一个组件，它可以向其他组件发送消息也可以接收来自其他组件的消息。

**发送源**
发送源通常使用`from: NodeName`来标识消息从哪个`Node`发出，`Schedular`是一个特殊的`Node`标识调度器消息。

**发送目标 MessageTo**

- Boardcast: 某个组件可以向所有组件发起一个广播消息，其他组件均可接收到广播消息。
- Point(NodeName): 一个组件可以向另一个组件发送消息

**消息处理结果 HandleResult**
当一个消息被处理完成后，需要反馈一个消息处理结果，目前定义了三种处理结果：

- Finish(Message): 消息成功处理，并反馈结果消息给消息发送者。
- Discard: 消息被丢弃不处理，无任何反馈结果。
- Pending: 消息需要进入 Pending 状态，后续调度器将不断周期性执行 poll 函数根据消息的唯一 seq 标识轮询结果消息，直到 Context 中的 async_ready 调用后标识消息处理完成的结果后消息才将回调给最初的发送者。

**同步消息调用**

Context 中的 `sync_call(ctx, message) -> HandleResult` 为同步消息调用，组件间的通信实际上就是直接的函数调用。

同步调用的优点：

简化组件的使用，可使得编码风格形成更加自然的业务流程的顺序调用。

同步调用的缺点：

注意这种调用可能会造成一些问题，如：

1. 两个组件互相循环通信时可能造成对同一个变量的两次可变借用从而使程序崩溃或获取两次锁造成死锁。
2. 组件相互通信可能导致程序陷入死循环，其他所有消息均无法正常调度，程序将死机。
3. 消息处理必须是短时间内可直接执行完毕的消息，调用完成后必须立刻返回 Finish 或 Discard 状态，禁止返回 Pending 状态。

**异步消息调用**

Context 中的 `async_call(ctx, message, FnOnce(HandleResult))` 为异步消息调用，实际上是发送一个异步消息到调度器的调度队列中进行调度，某一时刻若消息完成则通过回调函数异步通知发送者消息执行完毕。

异步调用的优点：

1. 两个组件循环通信本质上都是调度器在两个节点上依次消息调度，即使组件陷入长时间的消息循环，甚至无限循环，其他消息依旧可以正常调度。
2. 可以天然表达异步耗时任务的调用，可以使用 Pending 状态表明该消息需要等待一段时间后才能返回结果。

异步调用的缺点：

组件调用将必须以回调的形式接收结果，影响了代码风格。
当然若将 Rust 的 async 机制对接到调度器，可大大简化异步消息的代码风格(TODO)。
