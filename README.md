# V2 设计思想

V1 的开发中，为了实现跨平台编写了大量的抽象接口，同时为了性能考虑大量使用了智能指针。但由于个人的 Rust 开发经验不足导致代码逻辑较为混乱，代码后来维护不下去了，开始重开 v2 项目计划重写。

## 消息通信机制

原先的 v1 设计为了跨平台，需要分离出平台相关的接口与平台无关的接口，同时使用 trait 作为抽象并通过泛型进行静态分发，大量的静态分发的泛型定义导致代码越来越难以维护。

新版本采用消息传递机制完成整个 app 框架的设计，各个组件通过消息进行相互耦合通信，各个通信节点称为`Node`，通过枚举`NodeName`可以唯一标识一个组件。

### 目前项目中实现了以下消息通信机制:

**发送源**
发送源通常使用`NodeName`来标识消息从哪个`Node`发出，`Schedular`是一个特殊的`Node`标识调度器消息。

**发送目标**
- Boardcast: 某个组件可以向所有组件发起一个广播消息，其他组件均可接收到广播消息。
- Point: 一个组件可以向另一个组件发送消息
- Topic: 一些组件可以订阅指定的话题消息，某个组件可以向该话题下的所有组件发送话题消息。

**消息处理结果**
当一个消息被处理完成后，需要反馈一个消息处理结果，目前定义了三种处理结果：
- Successful(Message): 消息成功处理，并返回处理结果消息
- Discard(Message): 消息被丢弃不处理
- Error(Message): 消息发生错误，并返回错误消息

**消息反馈**
当一个消息发送者发送完一个消息后，可以通过回调异步地感知消息处理完成后的结果，可以使用`send_message_with_reply_once`只感知一次消息处理结果或使用`send_message_with_reply`允许感知多次消息处理结果。

## 消息通信图
